<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Parallelism in Aboria</title>
<link rel="stylesheet" href="../css/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="Aboria 0.7">
<link rel="up" href="../index.html" title="Aboria 0.7">
<link rel="prev" href="id_searching.html" title="ID Searching">
<link rel="next" href="evaluating_and_solving_kernel_op.html" title="Evaluating and Solving Kernel Operators with Eigen">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
    },
  TeX: { 
    extensions: ["AMSmath.js", "AMSsymbols.js"] 
    }
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48149829-4', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="Aboria" width="200" height="62" src="../images/aboria2.jpg"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="id_searching.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="evaluating_and_solving_kernel_op.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="aboria.parallelism_in_aboria"></a><a class="link" href="parallelism_in_aboria.html" title="Parallelism in Aboria">Parallelism in Aboria</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="parallelism_in_aboria.html#aboria.parallelism_in_aboria.openmp">OpenMP</a></span></dt>
<dt><span class="section"><a href="parallelism_in_aboria.html#aboria.parallelism_in_aboria.cuda">CUDA</a></span></dt>
</dl></div>
<p>
      Aboria can use OpenMP or CUDA to utilise multiple cores or Nvidia GPUs that
      you might have. In general, Aboria uses the parallel algorithms and vectors
      provided with <a href="http://thrust.github.io" target="_top">Thrust</a> to do this.
      From there, you can either use Thrust's OpenMP or CUDA backends to provide
      the type of parallelism you wish. However, there are a few parts of Aboria
      that are OpenMP only (notably the entirety of the <a class="link" href="symbolic_expressions.html" title="Symbolic Expressions">symbolic</a>
      and <a class="link" href="evaluating_and_solving_kernel_op.html" title="Evaluating and Solving Kernel Operators with Eigen">kernel</a> APIs).
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.parallelism_in_aboria.openmp"></a><a class="link" href="parallelism_in_aboria.html#aboria.parallelism_in_aboria.openmp" title="OpenMP">OpenMP</a>
</h3></div></div></div>
<p>
        You don't have to do much to start using OpenMP for the high level symbolic
        or kernel interfaces, all that is required is that you install OpenMP and
        Thrust and add the <code class="computeroutput"><span class="identifier">HAVE_THRUST</span></code>
        compiler definition (see <a class="link" href="installation_and_getting_started.html" title="Installation and Getting Started">aboria.installation_and_getting_started</a>).
        For lower-level programming you will need to add a few pragmas to your code,
        a few examples of which are discussed below.
      </p>
<p>
        First, let's create a set of <code class="computeroutput"><span class="identifier">N</span></code>
        particles as usual
      </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">size_t</span> <span class="identifier">N</span> <span class="special">=</span> <span class="number">100</span><span class="special">;</span>
<span class="identifier">ABORIA_VARIABLE</span><span class="special">(</span><span class="identifier">neighbour_count</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="string">"neighbour_count"</span><span class="special">);</span>
<span class="keyword">typedef</span> <span class="identifier">Particles</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">neighbour_count</span><span class="special">&gt;,</span> <span class="number">2</span><span class="special">&gt;</span> <span class="identifier">particle_t</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">particle_t</span><span class="special">::</span><span class="identifier">position</span> <span class="identifier">position</span><span class="special">;</span>
<span class="identifier">particle_t</span> <span class="identifier">particles</span><span class="special">(</span><span class="identifier">N</span><span class="special">);</span>
</pre>
<p>
        Now we will loop through the particles and set their initial positions randomly.
        In order to use an OpenMP parallel for loop, we will stick to a simple index-based
        loop for loop to iterate through the particles, like so
      </p>
<pre class="programlisting"><span class="preprocessor">#pragma</span> <span class="identifier">omp</span> <span class="identifier">parallel</span> <span class="keyword">for</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">particles</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">uniform_real_distribution</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">uniform</span><span class="special">(</span><span class="number">0</span><span class="special">,</span> <span class="number">1</span><span class="special">);</span>
      <span class="keyword">auto</span> <span class="identifier">gen</span> <span class="special">=</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">generator</span><span class="special">&gt;(</span><span class="identifier">particles</span><span class="special">)[</span><span class="identifier">i</span><span class="special">];</span>
      <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;(</span><span class="identifier">particles</span><span class="special">)[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">vdouble2</span><span class="special">(</span><span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">),</span> <span class="identifier">uniform</span><span class="special">(</span><span class="identifier">gen</span><span class="special">));</span>
    <span class="special">}</span>
</pre>
<p>
        Now we can initialise the neighbourhood search data structure. Note that
        all creation and updates to the spatial data structures are run in parallel.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          currently the only data structure that is created or updated in serial
          is <code class="computeroutput"><a class="link" href="../Aboria/KdtreeNanoflann.html" title="Class template KdtreeNanoflann">Aboria::KdtreeNanoflann</a></code>.
          All the rest are done in parallel using either OpenMP or CUDA
        </p></td></tr>
</table></div>
<pre class="programlisting"><span class="identifier">particles</span><span class="special">.</span><span class="identifier">init_neighbour_search</span><span class="special">(</span>
    <span class="identifier">vdouble2</span><span class="special">::</span><span class="identifier">Constant</span><span class="special">(</span><span class="number">0</span><span class="special">),</span> <span class="identifier">vdouble2</span><span class="special">::</span><span class="identifier">Constant</span><span class="special">(</span><span class="number">1</span><span class="special">),</span> <span class="identifier">vbool2</span><span class="special">::</span><span class="identifier">Constant</span><span class="special">(</span><span class="keyword">false</span><span class="special">));</span>
</pre>
<p>
        We will use Aboria's range search to look for neighbouring pairs within a
        cutoff, and once again use OpenMPs parallel loop. All queries to the spatial
        data structures are thread-safe and can be used in parallel.
      </p>
<pre class="programlisting">    <span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">radius</span> <span class="special">=</span> <span class="number">0.1</span><span class="special">;</span>

<span class="preprocessor">#pragma</span> <span class="identifier">omp</span> <span class="identifier">parallel</span> <span class="keyword">for</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">particles</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
      <span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">j</span> <span class="special">=</span> <span class="identifier">euclidean_search</span><span class="special">(</span><span class="identifier">particles</span><span class="special">.</span><span class="identifier">get_query</span><span class="special">(),</span>
                                     <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;(</span><span class="identifier">particles</span><span class="special">)[</span><span class="identifier">i</span><span class="special">],</span> <span class="identifier">radius</span><span class="special">);</span>
           <span class="identifier">j</span> <span class="special">!=</span> <span class="keyword">false</span><span class="special">;</span> <span class="special">++</span><span class="identifier">j</span><span class="special">)</span> <span class="special">{</span>
        <span class="special">++</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">neighbour_count</span><span class="special">&gt;(</span><span class="identifier">particles</span><span class="special">)[</span><span class="identifier">i</span><span class="special">];</span>
      <span class="special">}</span>
    <span class="special">}</span>
</pre>
<p>
        In general, that is 90% of what you need to know, just add a couple of OpenMP
        pragmas to your loops and you are ready to go!
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="aboria.parallelism_in_aboria.cuda"></a><a class="link" href="parallelism_in_aboria.html#aboria.parallelism_in_aboria.cuda" title="CUDA">CUDA</a>
</h3></div></div></div>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
          CUDA support in Aboria is experimental, and is not tested regularly. We
          welcome feedback by any CUDA users if anything doesn't work for you
        </p></td></tr>
</table></div>
<p>
        Writing CUDA compatible code is slightly more involved. Aboria uses the Thrust
        library for CUDA parallism, and follows similar patterns (i.e. STL-like).
      </p>
<p>
        Most importantly, we need to make sure that all the particle data is contained
        in vectors that are stored on the GPU. To do this we use a <code class="computeroutput"><span class="identifier">thrust</span><span class="special">::</span><span class="identifier">device_vector</span></code> as the base storage vector
        for our particles class
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          we want to use the type <code class="computeroutput"><span class="identifier">thrust_neighbour_count</span></code>
          within a device function, so we need to define this type outside any host
          functions (including main).
        </p></td></tr>
</table></div>
<pre class="programlisting"><span class="identifier">ABORIA_VARIABLE</span><span class="special">(</span><span class="identifier">thrust_neighbour_count</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="string">"thrust_neighbour_count"</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

<span class="keyword">typedef</span> <span class="identifier">Particles</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">thrust_neighbour_count</span><span class="special">&gt;,</span> <span class="number">2</span><span class="special">,</span>
                  <span class="identifier">thrust</span><span class="special">::</span><span class="identifier">device_vector</span><span class="special">,</span> <span class="identifier">CellListOrdered</span><span class="special">&gt;</span>
    <span class="identifier">thrust_particle_t</span><span class="special">;</span>
<span class="identifier">thrust_particle_t</span> <span class="identifier">thrust_particles</span><span class="special">(</span><span class="identifier">N</span><span class="special">);</span>
</pre>
<p>
        Since all our data is on the device, we cannot use raw for loops to access
        this data without copying it back to the host, an expensive operation. Instead,
        Thrust provides a wide variety of parallel algorithms to manipulate the data.
        Aboria's <code class="computeroutput"><a class="link" href="../Aboria/zip_iterator.html" title="Class template zip_iterator">Aboria::zip_iterator</a></code>
        is compatible with the Thrust framework, so can be used in a similar fashion
        to Thrust's own <code class="computeroutput"><span class="identifier">zip_iterator</span></code>
        (except, unlike Thrust's <code class="computeroutput"><span class="identifier">zip_iterator</span></code>,
        we can take advantage of Aboria's tagged <code class="computeroutput"><span class="identifier">reference</span></code>
        and <code class="computeroutput"><span class="identifier">value_types</span></code>).
      </p>
<p>
        We can use Thrust's <code class="computeroutput"><span class="identifier">tabulate</span></code>
        algorithm to loop through the particles and set their initial positions randomly.
      </p>
<pre class="programlisting"><span class="identifier">thrust</span><span class="special">::</span><span class="identifier">tabulate</span><span class="special">(</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;(</span><span class="identifier">thrust_particles</span><span class="special">).</span><span class="identifier">begin</span><span class="special">(),</span>
                 <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;(</span><span class="identifier">thrust_particles</span><span class="special">).</span><span class="identifier">end</span><span class="special">(),</span>
                 <span class="special">[]</span> <span class="identifier">__device__</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">int</span> <span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
                   <span class="identifier">thrust</span><span class="special">::</span><span class="identifier">default_random_engine</span> <span class="identifier">gen</span><span class="special">;</span>
                   <span class="identifier">thrust</span><span class="special">::</span><span class="identifier">uniform_real_distribution</span><span class="special">&lt;</span><span class="keyword">float</span><span class="special">&gt;</span> <span class="identifier">uni</span><span class="special">(</span><span class="number">0</span><span class="special">,</span> <span class="number">1</span><span class="special">);</span>
                   <span class="identifier">gen</span><span class="special">.</span><span class="identifier">discard</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>
                   <span class="keyword">return</span> <span class="identifier">vdouble2</span><span class="special">(</span><span class="identifier">uni</span><span class="special">(</span><span class="identifier">gen</span><span class="special">),</span> <span class="identifier">uni</span><span class="special">(</span><span class="identifier">gen</span><span class="special">));</span>
                 <span class="special">});</span>
</pre>
<p>
        Now we can initialise the neighbourhood search data structure. Note that
        we are using <code class="computeroutput"><a class="link" href="../Aboria/CellListOrdered.html" title="Class template CellListOrdered">Aboria::CellListOrdered</a></code>
        data structure, which is similar to <code class="computeroutput"><a class="link" href="../Aboria/CellList.html" title="Class template CellList">Aboria::CellList</a></code>
        but instead relies on reordering the particles to arrange them into cells,
        which is more amenable to parallelisation using a GPU.
      </p>
<pre class="programlisting"><span class="identifier">thrust_particles</span><span class="special">.</span><span class="identifier">init_neighbour_search</span><span class="special">(</span>
    <span class="identifier">vdouble2</span><span class="special">::</span><span class="identifier">Constant</span><span class="special">(</span><span class="number">0</span><span class="special">),</span> <span class="identifier">vdouble2</span><span class="special">::</span><span class="identifier">Constant</span><span class="special">(</span><span class="number">1</span><span class="special">),</span> <span class="identifier">vbool2</span><span class="special">::</span><span class="identifier">Constant</span><span class="special">(</span><span class="keyword">false</span><span class="special">));</span>
</pre>
<p>
        We can use any of Aboria's range searches within a Thrust algorithm. Below
        we will implement a range search around each particle, counting all neighbours
        within range. Note that we need to copy all of the variables from the outer
        scope to the lambda function, since the lambda will run on the device, and
        won't be able to access any host memory.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          The <code class="computeroutput"><a class="link" href="../Aboria/NeighbourQueryBase.html" title="Struct template NeighbourQueryBase">Aboria::NeighbourQueryBase</a></code>
          class for each spatial data structure is designed to be copyable to the
          GPU, but the <code class="computeroutput"><a class="link" href="../Aboria/Particles.html" title="Class template Particles">Aboria::Particles</a></code>
          class is not, so while the <code class="computeroutput"><span class="identifier">query</span></code>
          variable is copyable to the device, the <code class="computeroutput"><span class="identifier">thrust_particles</span></code>
          variable is not.
        </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          The type of variable <code class="computeroutput"><span class="identifier">i</span></code>
          in the lambda will be deduced as <code class="computeroutput"><a class="link" href="../Aboria/Particles.html#Aboria.Particles.raw_reference">Aboria::Particles::raw_reference</a></code>.
          This is different to <code class="computeroutput"><a class="link" href="../Aboria/Particles.html#Aboria.Particles.reference">Aboria::Particles::reference</a></code>
          when using <code class="computeroutput"><span class="identifier">thrust</span><span class="special">::</span><span class="identifier">device_vector</span></code>, but acts in a similar
          fashion
        </p></td></tr>
</table></div>
<pre class="programlisting"><span class="identifier">thrust</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span>
    <span class="identifier">thrust_particles</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">thrust_particles</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span>
    <span class="special">[</span><span class="identifier">radius</span><span class="special">,</span> <span class="identifier">query</span> <span class="special">=</span> <span class="identifier">thrust_particles</span><span class="special">.</span><span class="identifier">get_query</span><span class="special">()]</span> <span class="identifier">__device__</span><span class="special">(</span><span class="keyword">auto</span> <span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
      <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">thrust_neighbour_count</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
      <span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">j</span> <span class="special">=</span> <span class="identifier">euclidean_search</span><span class="special">(</span><span class="identifier">query</span><span class="special">,</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">),</span> <span class="identifier">radius</span><span class="special">);</span>
           <span class="identifier">j</span> <span class="special">!=</span> <span class="keyword">false</span><span class="special">;</span> <span class="special">++</span><span class="identifier">j</span><span class="special">)</span> <span class="special">{</span>
        <span class="special">++</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">thrust_neighbour_count</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">);</span>
      <span class="special">}</span>
    <span class="special">});</span>
</pre>
<p>
        While we have exclusively used <code class="computeroutput"><span class="identifier">thrust</span><span class="special">::</span><span class="identifier">for_each</span></code>
        above, the iterators that Aboria provides for the <code class="computeroutput"><a class="link" href="../Aboria/Particles.html" title="Class template Particles">Aboria::Particles</a></code>
        container should work with all of Thrust's algorithms. For example, you might
        wish to restructure the previous code as a transform:
      </p>
<pre class="programlisting">    <span class="identifier">thrust</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span>
        <span class="identifier">thrust_particles</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">thrust_particles</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span>
        <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">thrust_neighbour_count</span><span class="special">&gt;(</span><span class="identifier">thrust_particles</span><span class="special">).</span><span class="identifier">begin</span><span class="special">(),</span>
        <span class="special">[</span><span class="identifier">radius</span><span class="special">,</span> <span class="identifier">query</span> <span class="special">=</span> <span class="identifier">thrust_particles</span><span class="special">.</span><span class="identifier">get_query</span><span class="special">()]</span> <span class="identifier">__device__</span><span class="special">(</span><span class="keyword">auto</span> <span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
          <span class="keyword">int</span> <span class="identifier">sum</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
          <span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">j</span> <span class="special">=</span> <span class="identifier">euclidean_search</span><span class="special">(</span><span class="identifier">query</span><span class="special">,</span> <span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">position</span><span class="special">&gt;(</span><span class="identifier">i</span><span class="special">),</span> <span class="identifier">radius</span><span class="special">);</span>
               <span class="identifier">j</span> <span class="special">!=</span> <span class="keyword">false</span><span class="special">;</span> <span class="special">++</span><span class="identifier">j</span><span class="special">)</span> <span class="special">{</span>
            <span class="special">++</span><span class="identifier">sum</span><span class="special">;</span>
          <span class="special">}</span>
          <span class="keyword">return</span> <span class="identifier">sum</span><span class="special">;</span>
        <span class="special">});</span>
<span class="special">}</span>
</pre>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2015-2018 Martin
      Robinson</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="id_searching.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="evaluating_and_solving_kernel_op.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
